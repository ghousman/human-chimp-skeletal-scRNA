
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #Read in command line arguments as list of character vectors
> args=(commandArgs(TRUE))
> 
> #Check if arguments are passed and cycle through to evaluate each element
> if(length(args)==0){
+   print("No arguments supplied.")
+   #supply default values
+   name="noarg"
+   filter.arg=FALSE
+   filter.type="pch"
+   filter.param=0.2
+   subset.rep="NULL"
+   subset.num=FALSE
+   lfc=FALSE
+   fdr="BH"
+ }else{
+   for(i in 1:length(args)){
+     eval(parse(text=args[[i]]))
+   }
+ }
> print(paste0("file tag: ",name))
[1] "file tag: totcell.subNum.filter.pch20.fc.bh"
> print(paste0("cell assignment: ",assign))
[1] "cell assignment: stage"
> print(paste0("filter genes: ",filter.arg))
[1] "filter genes: TRUE"
> print(paste0("filter type: ",filter.type))
[1] "filter type: pch"
> print(paste0("gene filter.param: ",filter.param))
[1] "gene filter.param: 0.2"
> print(paste0("adjuste logFC in test: ",lfc))
[1] "adjuste logFC in test: TRUE"
> print(paste0("fdr method: ",fdr))
[1] "fdr method: BH"
> 
> #Load libraries
> library(Seurat)
> library(dplyr)

Attaching package: 'dplyr'

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union

> library(stringi)
> library(stringr)
> library(ggplot2)
> library(grid)
> library(gbm)
Loaded gbm 2.1.5
> library(colorspace)
> library(RColorBrewer)
> library(edgeR)
Loading required package: limma
> library(scran)
Loading required package: SingleCellExperiment
Loading required package: SummarizedExperiment
Loading required package: GenomicRanges
Loading required package: stats4
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: 'BiocGenerics'

The following objects are masked from 'package:parallel':

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following object is masked from 'package:limma':

    plotMA

The following objects are masked from 'package:dplyr':

    combine, intersect, setdiff, union

The following objects are masked from 'package:stats':

    IQR, mad, sd, var, xtabs

The following objects are masked from 'package:base':

    Filter, Find, Map, Position, Reduce, anyDuplicated, append,
    as.data.frame, basename, cbind, colnames, dirname, do.call,
    duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted,
    lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin,
    pmin.int, rank, rbind, rownames, sapply, setdiff, sort, table,
    tapply, union, unique, unsplit, which, which.max, which.min

Loading required package: S4Vectors

Attaching package: 'S4Vectors'

The following objects are masked from 'package:dplyr':

    first, rename

The following object is masked from 'package:base':

    expand.grid

Loading required package: IRanges

Attaching package: 'IRanges'

The following objects are masked from 'package:dplyr':

    collapse, desc, slice

Loading required package: GenomeInfoDb
Loading required package: Biobase
Welcome to Bioconductor

    Vignettes contain introductory material; view with
    'browseVignettes()'. To cite Bioconductor, see
    'citation("Biobase")', and for packages 'citation("pkgname")'.

Loading required package: DelayedArray
Loading required package: matrixStats

Attaching package: 'matrixStats'

The following objects are masked from 'package:Biobase':

    anyMissing, rowMedians

The following object is masked from 'package:dplyr':

    count

Loading required package: BiocParallel

Attaching package: 'DelayedArray'

The following objects are masked from 'package:matrixStats':

    colMaxs, colMins, colRanges, rowMaxs, rowMins, rowRanges

The following objects are masked from 'package:base':

    aperm, apply, rowsum


Attaching package: 'SummarizedExperiment'

The following object is masked from 'package:Seurat':

    Assays


Attaching package: 'SingleCellExperiment'

The following object is masked from 'package:edgeR':

    cpm

> library(SingleCellExperiment)
> 
> #Load data (integrate across individuals - total (15k genes))
> scrna <- "./../data/cellranger-data-full/data.filter.log.indv-cell.int19k-tot.assign.rds"
> data <- readRDS(scrna)
> data
An object of class Seurat 
38754 features across 101534 samples within 2 assays 
Active assay: integrated (19377 features)
 1 other assay present: RNA
 2 dimensional reductions calculated: pca, umap
> 
> #Isolate mitochondrial and ribosomal genes
> genes <- rownames(data@assays$RNA@counts)
> genes.mito <- c("MT-ATP6","MT-ATP8","MT-CO1","MT-CO2","MT-CO3","MT-CYB","MT-ND1","MT-ND2","MT-ND3","MT-ND4","MT-ND4L","MT-ND5")
> genes.ribo <- grep('^RP',genes,value=T)
> genes.no.mito.ribo <- genes[which(!(genes %in% c(genes.mito,genes.ribo)))]
> rm(genes,genes.mito,genes.ribo)
> 
> #Define EDGER Function
> runEDGER <- function(dataSub, cell.assign, cell.subset, genes.no.mito.ribo, filter.arg, filter.param, subset.rep) {
+ 
+   #count matrix
+   counts <- as.matrix(GetAssayData(dataSub, assay="RNA", slot="counts"))
+ 
+   #remove mitochodrial and ribosomal genes
+   counts <- counts[which(rownames(counts) %in% genes.no.mito.ribo),]
+ 
+   #metadata
+   metadata <- dataSub@meta.data[,c("Species","Collection","nCount_RNA","percent.mt","Phase")]
+   metadata <- metadata[colnames(counts),]
+ 
+   #make edgeR object
+   dge <- DGEList(counts)
+   meta_dge <- dge$samples[,c("lib.size","norm.factors")]
+   meta_dge <- cbind(meta_dge, metadata)
+   dge$samples <- meta_dge
+   rm(dataSub,counts,metadata,meta_dge)
+ 
+   #filter genes
+   if (filter.arg==TRUE){
+     if (filter.type=="min.count"){
+       keep <- filterByExpr(dge, group=dge$samples$Species, min.count=filter.param, min.total.count=15)
+       table(keep)
+       dge <- dge[keep, , keep.lib.sizes=FALSE]
+       rm(keep)
+     }
+     if (filter.type=="pch"){
+       dge$counts <- dge$counts[rowSums(dge$counts!=0)>=(filter.param*dim(dge$counts)[2]),]
+     }
+   }
+ 
+   #normalize data
+   dge <- calcNormFactors(dge, method="TMM")
+   summary(dge$samples$norm.factors)
+ 
+   #calculate cellular detection rate
+   cdr <- scale(colMeans(dge$count > 0))
+ 
+   #design matrix
+   dge$samples$Collection <- as.factor(as.numeric(dge$samples$Collection))
+   dge$samples$Phase <- as.factor(dge$samples$Phase)
+   dge$samples$Species <- as.factor(as.character(dge$samples$Species))
+   model <- "~Collection+cdr+nCount_RNA+percent.mt+Phase+Species"
+   design <- model.matrix(~Collection+cdr+nCount_RNA+percent.mt+Phase+Species, data=dge$samples)
+ 
+   dge <- estimateDisp(dge, design=design)
+   print(paste0("common dispersion: ",dge$common.dispersion))
+ 
+   #QLF model fit (quasi-likelihood ratio test) - reflects uncertainty in estimating dispersion for each gene
+   fit <- glmQLFit(dge, design=design, robust=TRUE)
+   head(fit$coefficients)
+ 
+   #differential expression between species
+   if(lfc==TRUE) {
+     qlf <- glmTreat(fit, coef=dim(design)[2], lfc=log2(1.2))
+   }
+   if(lfc==FALSE) {
+     qlf <- glmQLFTest(fit, coef=dim(design)[2], poisson.bound=TRUE)
+   }
+ 
+   #assess output
+   tt <- topTags(qlf, n=Inf, adjust.method=fdr, p.value=1)
+   print("All DE Genes")
+   print(dim(tt$table))
+   print(table(tt$table$FDR<0.01))
+   print(summary(decideTests(qlf, adjust.method=fdr, p.value=0.01)))
+ 
+   #add details to output
+   tt$table$data <- rep(scrna, dim(tt$table)[1])
+   tt$table$cell.assign <- rep(cell.assign, dim(tt$table)[1])
+   tt$table$cell.subset <- rep(cell.subset, dim(tt$table)[1])
+   tt$table$gene.filter <- rep(filter.arg, dim(tt$table)[1])
+   tt$table$gene.filter.args <- rep(paste0("filter.param=",filter.param), dim(tt$table)[1])
+   tt$table$subset.rep <- rep(subset.rep, dim(tt$table)[1])
+   tt$table$model <- rep(model, dim(tt$table)[1])
+   tt$table$comparison <- rep(tt$comparison, dim(tt$table)[1])
+   tt$table$test <- rep(tt$test, dim(tt$table)[1])
+   tt$table$adjust.method <- rep(tt$adjust.method, dim(tt$table)[1])
+   tt$table$gene <- rownames(tt$table)
+ 
+   return(tt$table)
+ 
+ }
> 
> #Find differentially expressed genes for different cell assignment subtypes
> if (assign=="all") {
+   subset.list <- list(stage=list("stage-Time 0","stage-Time 1","stage-Time 2"),
+                       clust=list("cluster-iPSC.c1","cluster-iPSC.c2","cluster-iPSC.c3","cluster-MSC.c1","cluster-Osteoblast.c1","cluster-Osteoblast.c2"),
+                       combI=c("cluster-iPSC.c1_iPSC.c2_iPSC.c3"),
+                       combO=c("cluster-Osteoblast.c1_Osteoblast.c2"),
+                       adhoc=list("adhoc-iPSC","adhoc-MSC","adhoc-Osteoblast"),
+                       ostadhoc=list("ostadhoc-preosteoblast","ostadhoc-embedding osteoblast"))
+ }
> if (assign=="stage") {
+   subset.list <- list(stage=list("stage-Time 0","stage-Time 1","stage-Time 2"))
+ }
> if (assign=="cluster") {
+   subset.list <- list(clust=list("cluster-iPSC.c1","cluster-iPSC.c2","cluster-iPSC.c3","cluster-MSC.c1","cluster-Osteoblast.c1","cluster-Osteoblast.c2"),
+                       combI=c("cluster-iPSC.c1_iPSC.c2_iPSC.c3"),
+                       combO=c("cluster-Osteoblast.c1_Osteoblast.c2"))
+ }
> if (assign=="adhoc") {
+   subset.list <- list(adhoc=list("adhoc-iPSC","adhoc-MSC","adhoc-Osteoblast"))
+ }
> if (assign=="ostadhoc") {
+   subset.list <- list(ostadhoc=list("ostadhoc-preosteoblast","ostadhoc-embedding osteoblast"))
+ }
> 
> edgr.total <- data.frame()
> 
> for (i in subset.list) {
+ 
+   for (j in i) {
+ 
+     print(j)
+ 
+     #define cell assignment and subtype of interest
+     cell.assign <- str_split(j,"-")[[1]][1]
+     cell.subset <- str_split(j,"-")[[1]][2]
+ 
+     #define data subset based on cell assignment criteria
+     if (str_count(cell.subset,"_")>=1){
+ 
+       if (length(str_split(cell.subset,"_")[[1]])==2) {
+         dataSub <- subset(data,
+                           subset=Cluster==str_split(cell.subset,"_")[[1]][1]|
+                             Cluster==str_split(cell.subset,"_")[[1]][2])
+       }
+       else {
+         dataSub <- subset(data,
+                           subset=Cluster==str_split(cell.subset,"_")[[1]][1]|
+                             Cluster==str_split(cell.subset,"_")[[1]][2]|
+                             Cluster==str_split(cell.subset,"_")[[1]][3])
+       }
+     }
+ 
+     else {
+       if(cell.assign=="stage") { dataSub <- subset(data,subset=Stage==cell.subset) }
+       if(cell.assign=="cluster") { dataSub <- subset(data,subset=Cluster==cell.subset) }
+       if(cell.assign=="adhoc") { dataSub <- subset(data,subset=AdHoc.Assign==cell.subset) }
+       if(cell.assign=="ostadhoc") { dataSub <- subset(data,subset=OstAdHoc.Assign==cell.subset) }
+     }
+ 
+     #further define data subsampling based on sample replicates
+     if(subset.rep=="keepRep1") {
+       print(subset.rep)
+       dataSub <- subset(dataSub,subset=Sample!="H1-I")
+       dataSub <- subset(dataSub,subset=Sample!="C1-I")
+     }
+     if(subset.rep=="keepRep2") {
+       print(subset.rep)
+       dataSub <- subset(dataSub,subset=Sample!="H1-I-r2")
+       dataSub <- subset(dataSub,subset=Sample!="C1-I-r2")
+     }
+ 
+     #further define data subsampling based on number of cells to sample for DE analysis
+     if(subset.num==TRUE) {
+       human.cells <- rownames(dataSub@meta.data)[which(dataSub@meta.data$Species=="Human")]
+       chimp.cells <- rownames(dataSub@meta.data)[which(dataSub@meta.data$Species=="Chimp")]
+       min.cell.count <- min(c(length(human.cells),length(chimp.cells)))
+       print(paste0("Minimum number of cells in comparative groups: ",min.cell.count))
+       h.cell.sub <- human.cells[sample(1:length(human.cells), min.cell.count, replace=FALSE)]
+       c.cell.sub <- chimp.cells[sample(1:length(chimp.cells), min.cell.count, replace=FALSE)]
+       dataSub <- subset(dataSub,cells=c(h.cell.sub,c.cell.sub))
+     }
+ 
+     #de analysis
+     edgr <- runEDGER(dataSub=dataSub,
+                      cell.assign=cell.assign,
+                      cell.subset=cell.subset,
+                      genes.no.mito.ribo=genes.no.mito.ribo,
+                      filter.arg=filter.arg,
+                      filter.param=filter.param,
+                      subset.rep=subset.rep)
+ 
+     edgr.total <- rbind(edgr.total,edgr)
+ 
+     print(dim(edgr.total))
+ 
+     saveRDS(edgr.total, file=paste0("./../data/de-data/DEedgeR.",name,".",assign,".rds"))
+ 
+   }
+ 
+ }
[1] "stage-Time 0"
[1] "Minimum number of cells in comparative groups: 16694"
[1] "common dispersion: 0.0792263957066027"
[1] "All DE Genes"
[1] 6611    5

FALSE  TRUE 
 3181  3430 
       SpeciesHuman
Down           1729
NotSig         3181
Up             1701
[1] 6611   16
[1] "stage-Time 1"
[1] "Minimum number of cells in comparative groups: 18713"
[1] "common dispersion: 0.197056153824302"
[1] "All DE Genes"
[1] 6778    5

FALSE  TRUE 
 3015  3763 
       SpeciesHuman
Down           2160
NotSig         3015
Up             1603
[1] 13389    16
[1] "stage-Time 2"
[1] "Minimum number of cells in comparative groups: 12565"
[1] "common dispersion: 0.301693169185788"
[1] "All DE Genes"
[1] 5561    5

FALSE  TRUE 
 2703  2858 
       SpeciesHuman
Down           1550
NotSig         2703
Up             1308
[1] 18950    16
> 
> 
> 
> proc.time()
     user    system   elapsed 
44574.324  1519.946 46213.320 
