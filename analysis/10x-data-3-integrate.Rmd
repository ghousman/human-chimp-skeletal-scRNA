---
title: "10x-data-integrate"
author: "Genevieve Housman"
date: "September 2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 10X Data Cellranger Analysis - Integrate Data

For each dataset, normalization, variance stabilization, and regression of unwanted variation were performed. Following this, datasets were integrated using shared highly variable genes.

The first question was how should the data be subsetted before normalization. The following subsets were assessed:

* separate species and cell types (n=6) (EX: Human iPSCs)
* separate human-chimp pairs and cell types (n=21) (EX: H1+C1 iPSCs)
* separate individuals and cell types (n=42) (EX: H1 iPSCs)
* separate species but keep all cell types together (n=2) (EX: Human iPSCs+MSCs+Osteoblasts)
* separate human-chimp pairs but keep all cell types together (n=7) (EX: H1+C1 iPSCs+MSCs+Osteoblasts)
* separate individuals but keep all cell types together (n=14) (EX: H1 iPSCs+MSCs+Osteoblasts)

However, the final datasets chosen and included here are:

* separate individuals and cell types (n=42) (EX: H1 iPSCs)
* separate individuals but keep all cell types together

**Step 1 - Normalization**

In Seurat the main normalization methods are:

1. Log Normalization
    + Within a cell, gene counts are divided by the total counts, multiplied by a scale.factor (10000), and natural-log transformed using log1p.
2. SCTransform
    + Alternative workflow that perfoms log normalization, variable feature identification, and data scaling in one command.

Because data are more difficult to manipulate with SCTransform, standard log normalization is used here.

**Step 2 - Calculate Cell Cycle Score**

Cell cycle scores are assigned to cells based on G2/M and S phase markers in each cell. The calculation depends on average gene expression levels across cells in a seurat object, so merging or subsetting data can affect these scores. Here, these scores are calculated within separate samples (n=42, each individual and cell type separated) rather than after different samples are merged together.

Possible Cell Cycle Assignments

* G1: beginning of interphase
* S: synthesis phase
* G2: end of interphase prior to mitosis

**Step 3 - Variance Stabilization**

Identifying variable genes depends on expression patterns across cells in a seurat object, so merging or subsetting data can affect which genes are identified as variable. Here, 

**Step 4 - Regression of Unwanted Variation**

Here, variation associated with related variables is not regressed out of the data subsets before integration.

**Step 5 - Data Integration**

In order to best call cell types across collections and species, data were integrated. Simple merging of datasets and even merging datasets using the intersect of the 6000 most variable genes in humans and chimpanzees (see scripts for previous trial runs below) retained unwanted variation. Thus, data were integrated to remove this unwanted variation and allow successful calling of cell types on biological variation of interest.

Data were integrated using reciprocal PCA combined with reference-based integration. This method (while perhaps less accurate than CCA) is more computationally efficient than other datasets, which is necessary for the large number of cells considered here. In this method, reciprocal PCA is performed to identify an effective space in which to find anchors. Specifically, each dataset is projected into every other dataset's PCA space, and anchors are contrained by the same mutual neighborhood requirement. Because a subset of databases are assigned as references, each dataset is compared to the references instead of performing all pairwise comparisons. During integration, the identified anchors between datasets (which represent pairwise correspondences between individual cells) are then used to harmonize the datasets (transfer information from one dataset to another).

***Additional Notes***

Because subset, merged, and integrated data reductions were correlated with UMI counts and percent of mitochondrial reads, several methods of regressing out this unwanted variation were tested. Cell cycle phase was also correlated with data reductions, but this variation was not regressed out because this is not recommended for differentiating cells.

* Option 1: regress out unwanted variation due to UMI counts and percent.mt while data are still in subsets
* Option 2: regress out unwanted variation due to UMI counts and percent.mt during reciprocal PCA integration set up
* Option 3: regress out unwanted variation due to UMI counts and percent.mt after data are integrated

**References**

* https://satijalab.org/seurat/v3.2/integration.html
* https://hbctraining.github.io/scRNA-seq/lessons/06_SC_SCT_and_integration.html
* https://hbctraining.github.io/scRNA-seq/lessons/cell_cycle_scoring.html
* See the following scripts for previous trial runs:
  + ./analysis/v1/v1-10x-data-normalize-log.Rmd
  + ./analysis/v1/v1-10x-data-normalize-sct.Rmd

```{r, eval=FALSE}

#Load libraries
library(Seurat)
library(dplyr)
library(stringi)
library(stringr)
library(ggplot2)
library(colorspace)
library(RColorBrewer)
library(tidyr)

```

### Load and Prepare Data

Prepare filtered 10X data by separating each individual and cell type into seperate datasets.

```{r, eval=FALSE}

#Load batch info
batch <- read.csv(file='./data/scrna-batch.csv', header=TRUE, sep=",")

#Read in files
data <- readRDS("./data/cellranger-data-full/data.filter.rds")

#Load cell cycle markers (Tirosh et al., 2016 Science) with seurat
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

#Separate human and chimp data within each collection into separate objects
objects <- list()
idx <- 1
for (i in 1:length(batch$Sample_Name_at_Core))
{
  obj <- subset(data[[i]], Species=='Human')
  objects[[idx]] <- CreateSeuratObject(obj@assays$RNA@counts, meta.data=obj@meta.data)
  idx <- idx+1
  obj <- subset(data[[i]], Species=='Chimp')
  objects[[idx]] <- CreateSeuratObject(obj@assays$RNA@counts, meta.data=obj@meta.data)
  idx <- idx+1
}
rm(data,obj,idx)

```

### Normalize Data and Score Cell Cycle

Because cell cycle score depends on average gene expression levels across cells in a seurat object, it is probably best to calculate these scores within separate samples (n=42, each individual and cell type separated) rather than after different samples are merged together.

```{r, eval=FALSE}

#Perform log normalization and cell cycle scoring on each individual and cell type
for (i in 1:length(objects)) {
  print(i)
  objects[[i]] <- NormalizeData(objects[[i]], normalization.method="LogNormalize", scale.factor=10000, verbose=FALSE)
  objects[[i]] <- CellCycleScoring(objects[[i]], s.features=s.genes, g2m.features=g2m.genes, set.ident=FALSE)
}
rm(s.genes,g2m.genes,i)

```

### Merge Data into Different Subsets

Datasets include:

* cells separated by individual and cell type (n=42)
* cells separated by individual (n=14)
* all cells from Time 0 collections (n=1)
* all cells from Time 1 collections (n=1)
* all cells from Time 2 collections (n=1)
* all cells from all collections (n=1)

```{r, eval=FALSE}

#keep collections separated by individual and cell type (.log.indv-cell)
#objects

#merge T0, T1, and T2 collections within each individual (.log.indv)
objects[[43]] <- merge(objects[[1]], y=c(objects[[3]],objects[[5]]),add.cell.ids=c("H1.I","H1.M","H1.O"))
objects[[44]] <- merge(objects[[7]], y=c(objects[[9]],objects[[11]]),add.cell.ids=c("H1r2.I","H1r2.M","H1r2.O"))
objects[[45]] <- merge(objects[[13]], y=c(objects[[15]],objects[[17]]),add.cell.ids=c("H2.I","H2.M","H2.O"))
objects[[46]] <- merge(objects[[19]], y=c(objects[[21]],objects[[23]]),add.cell.ids=c("H3.I","H3.M","H3.O"))
objects[[47]] <- merge(objects[[25]], y=c(objects[[27]],objects[[29]]),add.cell.ids=c("H4.I","H4.M","H4.O"))
objects[[48]] <- merge(objects[[31]], y=c(objects[[33]],objects[[35]]),add.cell.ids=c("H5.I","H5.M","H5.O"))
objects[[49]] <- merge(objects[[37]], y=c(objects[[39]],objects[[41]]),add.cell.ids=c("H6.I","H6.M","H6.O"))
objects[[50]] <- merge(objects[[2]], y=c(objects[[4]],objects[[6]]),add.cell.ids=c("C1.I","C1.M","C1.O"))
objects[[51]] <- merge(objects[[8]], y=c(objects[[10]],objects[[12]]),add.cell.ids=c("C1r2.I","C1r2.M","C1r2.O"))
objects[[52]] <- merge(objects[[14]], y=c(objects[[16]],objects[[18]]),add.cell.ids=c("C2.I","C2.M","C2.O"))
objects[[53]] <- merge(objects[[20]], y=c(objects[[22]],objects[[24]]),add.cell.ids=c("C3.I","C3.M","C3.O"))
objects[[54]] <- merge(objects[[26]], y=c(objects[[28]],objects[[30]]),add.cell.ids=c("C4.I","C4.M","C4.O"))
objects[[55]] <- merge(objects[[32]], y=c(objects[[34]],objects[[36]]),add.cell.ids=c("C5.I","C5.M","C5.O"))
objects[[56]] <- merge(objects[[38]], y=c(objects[[40]],objects[[42]]),add.cell.ids=c("C6.I","C6.M","C6.O"))

#merge all T0 collections (.log.t0)
objects[[57]] <- merge(objects[[1]],
                        y=c(objects[[7]],objects[[13]],objects[[19]],objects[[25]],objects[[31]],objects[[37]],
                            objects[[2]],objects[[8]],objects[[14]],objects[[20]],objects[[26]],objects[[32]],objects[[38]]),
                        add.cell.ids=c("H1.I","H1r2.I","H2.I","H3.I","H4.I","H5.I","H6.I",
                                       "C1.I","C1r2.I","C2.I","C3.I","C4.I","C5.I","C6.I"))

#merge all T1 collections (.log.t1)
objects[[58]] <- merge(objects[[3]],
                        y=c(objects[[9]],objects[[15]],objects[[21]],objects[[27]],objects[[33]],objects[[39]],
                            objects[[4]],objects[[10]],objects[[16]],objects[[22]],objects[[28]],objects[[34]],objects[[40]]),
                        add.cell.ids=c("H1.M","H1r2.M","H2.M","H3.M","H4.M","H5.M","H6.M",
                                       "C1.M","C1r2.M","C2.M","C3.M","C4.M","C5.M","C6.M"))

#merge all T2 collections (.log.t2)
objects[[59]] <- merge(objects[[5]],
                        y=c(objects[[11]],objects[[17]],objects[[23]],objects[[29]],objects[[35]],objects[[41]],
                            objects[[6]],objects[[12]],objects[[18]],objects[[24]],objects[[30]],objects[[36]],objects[[42]]),
                        add.cell.ids=c("H1.O","H1r2.O","H2.O","H3.O","H4.O","H5.O","H6.O",
                                       "C1.O","C1r2.O","C2.O","C3.O","C4.O","C5.O","C6.O"))

#merge all collections (.log.tot)
objects[[60]] <- merge(objects[[1]],
                        y=c(objects[[7]],objects[[13]],objects[[19]],objects[[25]],objects[[31]],objects[[37]],
                            objects[[2]],objects[[8]],objects[[14]],objects[[20]],objects[[26]],objects[[32]],objects[[38]],
                            objects[[3]],objects[[9]],objects[[15]],objects[[21]],objects[[27]],objects[[33]],objects[[39]],
                            objects[[4]],objects[[10]],objects[[16]],objects[[22]],objects[[28]],objects[[34]],objects[[40]],
                            objects[[5]],objects[[11]],objects[[17]],objects[[23]],objects[[29]],objects[[35]],objects[[41]],
                            objects[[6]],objects[[12]],objects[[18]],objects[[24]],objects[[30]],objects[[36]],objects[[42]]),
                        add.cell.ids=c("H1.I","H1r2.I","H2.I","H3.I","H4.I","H5.I","H6.I",
                                       "C1.I","C1r2.I","C2.I","C3.I","C4.I","C5.I","C6.I",
                                       "H1.M","H1r2.M","H2.M","H3.M","H4.M","H5.M","H6.M",
                                       "C1.M","C1r2.M","C2.M","C3.M","C4.M","C5.M","C6.M",
                                       "H1.O","H1r2.O","H2.O","H3.O","H4.O","H5.O","H6.O",
                                       "C1.O","C1r2.O","C2.O","C3.O","C4.O","C5.O","C6.O"))

```

### Find Variable Features, Stabilize Variance, and Reduce Data Dimensionality

Which variable features are identified depends on which samples are included in the seurat object. This is why different sets of merged data are first compiled before then assessing variable feature in the merged dataset.

When scaling the data, no variables are regressed out at this time.

To QC each data subset, dimensional reduction is also performed.

```{r, eval=FALSE}

#Identify variable feature for each individual and cell type
for (i in 1:length(objects)) {
  print(i)
  objects[[i]] <- FindVariableFeatures(objects[[i]], selection.method="vst", nfeatures=3000, verbose=FALSE)
  objects[[i]] <- ScaleData(objects[[i]], vars.to.regress=NULL, verbose=FALSE)
  #objects[[i]] <- ScaleData(objects[[i]], vars.to.regress=c("nCount_RNA","percent.mt"))
  objects[[i]] <- RunPCA(objects[[i]], npcs=100, verbose=FALSE)
  #keep all dims that explaim more than 0.1% of variance
  pva <- objects[[i]]@reductions$pca@stdev^2/objects[[i]]@reductions$pca@misc$total.variance
  ndim <- length(which(pva>=0.001))
  objects[[i]] <- RunUMAP(objects[[i]], dims=1:ndim)
}
rm(pva,ndim,i)

```

### Save Data Subsets

```{r, eval=FALSE}

#Save data
saveRDS(objects[1:42], file="./data/cellranger-data-full/data.filter.log.indv-cell.rds")
saveRDS(objects[43:56], file="./data/cellranger-data-full/data.filter.log.indv.rds")
saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.merge-t0.rds")
saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.merge-t1.rds")
saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.merge-t2.rds")
saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.merge-tot.rds")
rm(batch, objects)

#saveRDS(objects[1:42], file="./data/cellranger-data-full/data.filter.log.reg.indv-cell.rds")
#saveRDS(objects[43:56], file="./data/cellranger-data-full/data.filter.log.reg.indv.rds")
#saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.reg.merge-t0.rds")
#saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.reg.merge-t1.rds")
#saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.reg.merge-t2.rds")
#saveRDS(objects[57], file="./data/cellranger-data-full/data.filter.log.reg.merge-tot.rds")
#rm(batch, objects)

```

### QC of Data Subsets

All subsets show variation correlated with UMI counts per cell (nCount_RNA), gene counts per cell (nFeature_RNA), percent of mitochondrial reads (percent.mt), and cell cycle phase (Phase, S.Score, G2M.Score). For subsets containing three collections (Time 0, Time 1, Time 2) for one cell line, batch effects associated with collection are also correlated with expression variation (Collection, Stage, Sample, PrewashViability, PostwashViability, PostmixViability, CD90, CD73, CD105, CD45.CD34.CD11b.CD19.HLA.DR, Alizarin, OilRed).

```{r, eval=FALSE}

#Define function for making heatmap of data reductions vs. batch correlations
batchPlot <- function(data,text,batch) {
  
  df <- data@meta.data[,which(colnames(data@meta.data) %in% batch)]
  df <- cbind(df,data@reductions$pca@cell.embeddings[,1:10])
  df <- df[,colSums(is.na(df))<nrow(df)]
  
  y <- dim(df)[2]
  x <- y-10
  
  #Make correlation matrix
  cov.cor <- matrix(ncol=10, nrow=x, dimnames=list(colnames(df)[1:x], colnames(df)[(x+1):y]))
  
  j=1
  while (j <= 10) { 
    k=1
    while (k <= x) { 
      if (length(unique(df[,0+k]))>1) {
        lm_result <- lm(df[,x+j] ~ df[,0+k]) 
        r2 <- summary(lm_result)$r.squared 
        cov.cor[k, j] <- r2 
      }
      if (length(unique(df[,0+k]))==1) {
        cov.cor[k, j] <- NA
      }
      k=k+1
    }
    j=j+1
  }
  
  #Convert to long format to plot in ggplot2
  cov.cor.df <- as.data.frame(cov.cor) 
  cov.cor.df$batch <- rownames(cov.cor.df) 
  cov.cor.df <- gather(cov.cor.df, key="reduction", value="cor", -batch) 
  head(cov.cor.df) 
  
  #Plot heatmap
  cov.cor.df$batch <- factor(cov.cor.df$batch, 
                             levels = unique(cov.cor.df$batch), 
                             labels = unique(cov.cor.df$batch))
  
  cov.cor.df$reduction <- factor(cov.cor.df$reduction, 
                                 levels = unique(cov.cor.df$reduction),
                                 labels = unique(cov.cor.df$reduction)) 
  
  title <- paste0("Correlation between data reductions and batch effects\n",text)
  
  return(print(ggplot(cov.cor.df, aes(x=reduction, y=batch, fill=cor)) +
                 geom_tile(color="white") +
                 scale_fill_gradient(low="white", high="darkgrey", limits=c(0, 1)) + 
                 labs(title=title, x="", y="") +
                 theme(axis.text.x=element_text(angle=90, hjust=1))))
  
}

```

```{r, eval=FALSE}

#Define function for making plots and output files
qcPlots <-function(data,text,batch) {
  
  batch.factor <- c("Stage","Species","Collection","Pair","Individual","Replicate","MSCmedia","Sample","Sex","Age","Number6W","SequencingBatch","Phase")
  batch.number <- c("nCount_RNA","nFeature_RNA","percent.mt","PrewashViability","PostwashViability","PostmixViability",
                    "CD90","CD73","CD105","CD45.CD34.CD11b.CD19.HLA.DR","Alizarin","OilRed","S.Score","G2M.Score")
  
  plotList <- list()
  
  i=1
  while (i <= length(batch)) {
    
    if (sum(is.na(data@meta.data[,batch[[i]]]))<nrow(data@meta.data)) {
      if (batch[[i]] %in% batch.factor) {
        plotList[[i]] <- CombinePlots(plots=list((DimPlot(data, group.by=batch[[i]], reduction="umap") + labs(x="UMAP1",y="UMAP2")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(1,2)) + labs(x="PC1",y="PC2")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(3,4)) + labs(x="PC3",y="PC4")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(5,6)) + labs(x="PC5",y="PC6")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(7,8)) + labs(x="PC7",y="PC8")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(9,10)) + labs(x="PC9",y="PC10"))), ncol=6)
      }
      if (batch[[i]] %in% batch.number) {
        plotList[[i]] <- CombinePlots(plots=list((FeaturePlot(data, features=batch[[i]], reduction="umap") + labs(x="UMAP1",y="UMAP2")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(1,2)) + labs(x="PC1",y="PC2")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(3,4)) + labs(x="PC3",y="PC4")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(5,6)) + labs(x="PC5",y="PC6")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(7,8)) + labs(x="PC7",y="PC8")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(9,10)) + labs(x="PC9",y="PC10"))), ncol=6)
      }
    }
    
    else {
      plotList[[i]] <- grid.rect(gp=gpar(col="white"))
    }
      
    i=i+1

  }
  
  return(print(grid.arrange(grobs=plotList, ncol=1, top=textGrob(text,gp=gpar(fontsize=20)))))
  
}

```

```{r, eval=FALSE}

#Load information of data to be examined

obj.set1 <- readRDS("./data/cellranger-data-full/data.filter.log.indv-cell.rds")
obj.set2 <- readRDS("./data/cellranger-data-full/data.filter.log.indv.rds")
#obj.set1 <- readRDS("./data/cellranger-data-full/data.filter.log.reg.indv-cell.rds")
#obj.set2 <- readRDS("./data/cellranger-data-full/data.filter.log.reg.indv.rds")
objects <- append(obj.set1,obj.set2)
rm(obj.set1,obj.set2)

batch <- c("Stage","Species","Collection","Pair","Individual","Replicate","MSCmedia","Sample","Sex","Age","Number6W","SequencingBatch",
           "Phase","nCount_RNA","nFeature_RNA","percent.mt","PrewashViability","PostwashViability","PostmixViability",
           "CD90","CD73","CD105","CD45.CD34.CD11b.CD19.HLA.DR","Alizarin","OilRed","S.Score","G2M.Score")

#Calculate and plot correlation of batch with first 10 PCs and UMAP
pdf(file=paste0("./output/data-qc-postfilter-subsets-batchcor.pdf"), onefile=TRUE, width=7, height=7)
#pdf(file=paste0("./output/data-qc-postfilter-subsets.reg-batchcor.pdf"), onefile=TRUE, width=7, height=7)
i=1
for (i in 1:length(objects)) {
  print(i)
  text <- paste0("subset ",i)
  data <- objects[[i]]
  batchPlot(data,text)
  i=i+1
}
dev.off()

#Visualize batch effects in PC and UMAP space
pdf(file="./output/data-qc-postfilter-subsets-batchviz.pdf", onefile=TRUE, width=18, height=81)
#pdf(file="./output/data-qc-postfilter-subsets.reg-batchviz.pdf", onefile=TRUE, width=18, height=81)
i=1
for (i in 1:length(objects)) {
  text <- paste0("subset ",i)
  data <- objects[[i]]
  print(text)
  qcPlots(data,text,batch)
  i=i+1
}
dev.off()

```

### Data Integration

Datasets used:

* separate individuals and cells types
    + integrated Time 0 cells
    + integrated Time 1 cells
    + integrated Time 2 cells
* separate individuals but keep all cell types together
    + integrated all cells

Cells were integrated using different methods:

* 10000 genes used as integration anchors; no variables regressed out during scale data (int)
* 19377 genes used as integration anchors; no variables regressed out during scale data (int19k)

Steps for each integration:

* Define list subset
* Select features for downstream integration
* Identify anchors (used references + RPCA reduction method) [note: all other integration methods crash]
* Integrate datasets
* Reduce dimensionality
* Save data

```{r, eval=FALSE}

#Load objects
dataCell <- readRDS("./data/cellranger-data-full/data.filter.log.indv-cell.rds")
#dataCell <- readRDS("./data/cellranger-data-full/data.filter.log.reg.indv-cell.rds")

```

```{r, eval=FALSE}

#Combine Time 0 cells from all samples

obj  <- list(dataCell[[1]],dataCell[[2]],
             dataCell[[7]],dataCell[[8]],
             dataCell[[13]],dataCell[[14]],
             dataCell[[19]],dataCell[[20]],
             dataCell[[25]],dataCell[[26]],
             dataCell[[31]],dataCell[[32]],
             dataCell[[37]],dataCell[[38]])

#obj.features <- SelectIntegrationFeatures(object.list=obj, nfeatures=10000)
obj.features <- rownames(dataCell[[1]]@assays$RNA@counts) #all 19377 genes

ref.data <- c(3:4) #H1-r2 and C1-r2 differentiated best

obj <- lapply(X=obj, FUN=function(x) {
  x <- ScaleData(x, features=obj.features, verbose=FALSE)
  #x <- ScaleData(x, features=obj.features, vars.to.regress=c("nCount_RNA","percent.mt"))
  x <- RunPCA(x, features=obj.features, verbose=FALSE)
})

obj.anchors <- FindIntegrationAnchors(object.list=obj,
                                      normalization.method="LogNormalize",
                                      anchor.features=obj.features,
                                      reference=ref.data,
                                      reduction="rpca")

integrate <- IntegrateData(anchorset=obj.anchors,
                           normalization.method="LogNormalize")

integrate <- ScaleData(integrate, vars.to.regress=NULL, verbose=FALSE)
###integrate <- ScaleData(integrate, vars.to.regress=c("nCount_RNA","percent.mt")) #TAKES TOO LONG TO RUN

integrate <- RunPCA(object=integrate,
                    npcs=100,
                    verbose=FALSE)

#keep all dims that explaim more than 0.1% of variance
pva <- integrate@reductions$pca@stdev^2/integrate@reductions$pca@misc$total.variance
ndim <- length(which(pva>=0.001))
print(ndim)

integrate <- RunUMAP(integrate,
                     dims=1:ndim)

#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int-t0.rds")
saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t0.rds")
#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.reg.indv-cell.int19k-t0.rds")
#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.reg.int19k-t0.rds")
#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int19k.reg-t0.rds")

rm(obj,obj.features,obj.anchors,ref.data,integrate,pva,ndim)

```

### TEMPORARY CODE TO TEST VAR.REGRESS

```{r TEMPORARY}

data <- readRDS("./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t0.rds")
FeaturePlot(data, features=c("nCount_RNA","percent.mt"))

#integrate <- readRDS("./data/cellranger-data-full/data.filter.log.reg.indv-cell.int19k-t0.rds")
#integrate <- readRDS("./data/cellranger-data-full/data.filter.log.indv-cell.reg.int19k-t0.rds")
integrate <- readRDS("./data/cellranger-data-full/data.filter.log.indv-cell.int19k.reg-t0.rds")
FeaturePlot(integrate, features=c("nCount_RNA","percent.mt"), reduction="umap")
batchPlot(integrate,"int19kreg(step1)",batch)

```

```{r, eval=FALSE}

#Combine Time 1 cells from all samples

obj   <- list(dataCell[[3]],dataCell[[4]],
              dataCell[[9]],dataCell[[10]],
              dataCell[[15]],dataCell[[16]],
              dataCell[[21]],dataCell[[22]],
              dataCell[[27]],dataCell[[28]],
              dataCell[[33]],dataCell[[34]],
              dataCell[[39]],dataCell[[40]])

#obj.features <- SelectIntegrationFeatures(object.list=obj, nfeatures=10000)
obj.features <- rownames(dataCell[[3]]@assays$RNA@counts) #all 19377 genes

ref.data <- c(3:4) #H1-r2 and C1-r2 differentiated best

obj <- lapply(X=obj, FUN=function(x) {
  x <- ScaleData(x, features=obj.features, verbose=FALSE)
  x <- RunPCA(x, features=obj.features, verbose=FALSE)
})

obj.anchors <- FindIntegrationAnchors(object.list=obj,
                                      normalization.method="LogNormalize",
                                      anchor.features=obj.features,
                                      reference=ref.data,
                                      reduction="rpca")

integrate <- IntegrateData(anchorset=obj.anchors,
                           normalization.method="LogNormalize")

integrate <- ScaleData(integrate, vars.to.regress=NULL, verbose=FALSE)

integrate <- RunPCA(object=integrate,
                    npcs=100,
                    verbose=FALSE)

#keep all dims that explaim more than 0.1% of variance
pva <- integrate@reductions$pca@stdev^2/integrate@reductions$pca@misc$total.variance
ndim <- length(which(pva>=0.001))
print(ndim)

integrate <- RunUMAP(integrate,
                     dims=1:ndim)

#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int-t1.rds")
saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t1.rds")

rm(obj,obj.features,obj.anchors,ref.data,integrate,pva,ndim)

```

```{r, eval=FALSE}

#Combine Time 2 cells from all samples

obj <- list(dataCell[[5]],dataCell[[6]],
            dataCell[[11]],dataCell[[12]],
            dataCell[[17]],dataCell[[18]],
            dataCell[[23]],dataCell[[24]],
            dataCell[[29]],dataCell[[30]],
            dataCell[[35]],dataCell[[36]],
            dataCell[[41]],dataCell[[42]])

#obj.features <- SelectIntegrationFeatures(object.list=obj, nfeatures=10000)
obj.features <- rownames(dataCell[[5]]$RNA@counts) #all 19377 genes

ref.data <- c(3:4) #H1-r2 and C1-r2 differentiated best

obj <- lapply(X=obj, FUN=function(x) {
  x <- ScaleData(x, features=obj.features, verbose=FALSE)
  x <- RunPCA(x, features=obj.features, verbose=FALSE)
})

obj.anchors <- FindIntegrationAnchors(object.list=obj,
                                      normalization.method="LogNormalize",
                                      anchor.features=obj.features,
                                      reference=ref.data,
                                      reduction="rpca")

integrate <- IntegrateData(anchorset=obj.anchors,
                           normalization.method="LogNormalize")

integrate <- ScaleData(integrate, vars.to.regress=NULL, verbose=FALSE)

integrate <- RunPCA(object=integrate,
                    npcs=100,
                    verbose=FALSE)

#keep all dims that explaim more than 0.1% of variance
pva <- integrate@reductions$pca@stdev^2/integrate@reductions$pca@misc$total.variance
ndim <- length(which(pva>=0.001))
print(ndim)

integrate <- RunUMAP(integrate,
                     dims=1:ndim)

#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int-t2.rds")
saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t2.rds")

rm(obj,obj.features,obj.anchors,ref.data,integrate,pva,ndim)

```

```{r, eval=FALSE}

rm(dataCell)

```

```{r, eval=FALSE}

#Combine all cells from all samples

obj <- readRDS("./data/cellranger-data-full/data.filter.log.indv.rds")

#obj.features <- SelectIntegrationFeatures(object.list=obj, nfeatures=10000)
obj.features <- rownames(obj[[1]]@assays$RNA@counts) #all 19377 genes

ref.data <- c(2,9) #H1-r2 and C1-r2 differentiated best

obj <- lapply(X=obj, FUN=function(x) {
  x <- ScaleData(x, features=obj.features, verbose=FALSE)
  x <- RunPCA(x, features=obj.features, verbose=FALSE)
})

obj.anchors <- FindIntegrationAnchors(object.list=obj,
                                      normalization.method="LogNormalize",
                                      anchor.features=obj.features,
                                      reference=ref.data,
                                      reduction="rpca")

integrate <- IntegrateData(anchorset=obj.anchors,
                           normalization.method="LogNormalize")

integrate <- ScaleData(integrate, vars.to.regress=NULL, verbose=FALSE)

integrate <- RunPCA(object=integrate,
                    npcs=100,
                    verbose=FALSE)

#keep all dims that explaim more than 0.1% of variance
pva <- integrate@reductions$pca@stdev^2/integrate@reductions$pca@misc$total.variance
ndim <- length(which(pva>=0.001))
print(ndim)

integrate <- RunUMAP(integrate,
                     dims=1:ndim)

#saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int-tot.rds")
saveRDS(integrate, file="./data/cellranger-data-full/data.filter.log.indv-cell.int19k-tot.rds")

rm(obj,obj.features,obj.anchors,ref.data,integrate,pva,ndim)

```

### QC of Merged and Integrated Data - NEED TO UPDATE DESCRIPTIVE TEXT

Results of correlations between expression data reductions and batch effects:

* Merged Data
  + variation correlated with UMI counts per cell (nCount_RNA), gene counts per cell (nFeature_RNA), and percent of mitochondrial reads (percent.mt)
  + variation correlated with collection-associated batch effects (Sample, Individual, Pair, Age, CD90)
  + variation correlated with species
  + variation not correlated with cell cycle phase (Phase, S.Score, G2M.Score)
* Integrated Data
  + variation correlated with UMI counts per cell (nCount_RNA), gene counts per cell (nFeature_RNA), percent of mitochondrial reads (percent.mt), and cell cycle phase (Phase, S.Score, G2M.Score)
  + variation not collection-associated batch effects (Sample, Individual, Pair, Age, CD90)
  + variation not correlated with species

```{r, eval=FALSE}

#Define function for making heatmap of data reductions vs. batch correlations
batchPlot <- function(data,text,batch) {
  
  df <- data@meta.data[,which(colnames(data@meta.data) %in% batch)]
  df <- cbind(df,data@reductions$pca@cell.embeddings[,1:10])
  df <- cbind(df,data@reductions$umap@cell.embeddings[,1:2])
  df <- df[,colSums(is.na(df))<nrow(df)]
  
  y <- dim(df)[2]
  x <- y-12
  
  #Make correlation matrix
  cov.cor <- matrix(ncol=12, nrow=x, dimnames=list(colnames(df)[1:x], colnames(df)[(x+1):y]))
  
  j=1
  while (j <= 12) { 
    k=1
    while (k <= x) { 
      if (length(unique(df[,0+k]))>1) {
        lm_result <- lm(df[,x+j] ~ df[,0+k]) 
        r2 <- summary(lm_result)$r.squared 
        cov.cor[k, j] <- r2 
      }
      if (length(unique(df[,0+k]))==1) {
        cov.cor[k, j] <- NA
      }
      k=k+1
    }
    j=j+1
  }
  
  #Convert to long format to plot in ggplot2
  cov.cor.df <- as.data.frame(cov.cor) 
  cov.cor.df$batch <- rownames(cov.cor.df) 
  cov.cor.df <- gather(cov.cor.df, key="reduction", value="cor", -batch) 
  head(cov.cor.df) 
  
  #Plot heatmap
  cov.cor.df$batch <- factor(cov.cor.df$batch, 
                             levels = unique(cov.cor.df$batch), 
                             labels = unique(cov.cor.df$batch))
  
  cov.cor.df$reduction <- factor(cov.cor.df$reduction, 
                                 levels = unique(cov.cor.df$reduction),
                                 labels = unique(cov.cor.df$reduction)) 
  
  title <- paste0("Correlation between data reductions and batch effects\n",text)
  
  return(print(ggplot(cov.cor.df, aes(x=reduction, y=batch, fill=cor)) +
                 geom_tile(color="white") +
                 scale_fill_gradient(low="white", high="darkgrey", limits=c(0, 1)) + 
                 labs(title=title, x="", y="") +
                 theme(axis.text.x=element_text(angle=90, hjust=1))))
  
}

```

```{r, eval=FALSE}

#Define function for making plots and output files
qcPlots <-function(data,text,batch) {
  
  batch.factor <- c("Stage","Species","Collection","Pair","Individual","Replicate","MSCmedia","Sample","Sex","Age","Number6W","SequencingBatch","Phase")
  batch.number <- c("nCount_RNA","nFeature_RNA","percent.mt","PrewashViability","PostwashViability","PostmixViability",
                    "CD90","CD73","CD105","CD45.CD34.CD11b.CD19.HLA.DR","Alizarin","OilRed","S.Score","G2M.Score")
  
  plotList <- list()
  
  i=1
  while (i <= length(batch)) {
    
    if (sum(is.na(data@meta.data[,batch[[i]]]))<nrow(data@meta.data)) {
      if (batch[[i]] %in% batch.factor) {
        plotList[[i]] <- CombinePlots(plots=list((DimPlot(data, group.by=batch[[i]], reduction="umap") + labs(x="UMAP1",y="UMAP2")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(1,2)) + labs(x="PC1",y="PC2")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(3,4)) + labs(x="PC3",y="PC4")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(5,6)) + labs(x="PC5",y="PC6")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(7,8)) + labs(x="PC7",y="PC8")),
                                                 (DimPlot(data, group.by=batch[[i]], reduction="pca", dims=c(9,10)) + labs(x="PC9",y="PC10"))), ncol=6)
      }
      if (batch[[i]] %in% batch.number) {
        plotList[[i]] <- CombinePlots(plots=list((FeaturePlot(data, features=batch[[i]], reduction="umap") + labs(x="UMAP1",y="UMAP2")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(1,2)) + labs(x="PC1",y="PC2")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(3,4)) + labs(x="PC3",y="PC4")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(5,6)) + labs(x="PC5",y="PC6")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(7,8)) + labs(x="PC7",y="PC8")),
                                                 (FeaturePlot(data, features=batch[[i]], reduction="pca", dims=c(9,10)) + labs(x="PC9",y="PC10"))), ncol=6)
      }
    }
    
    else {
      plotList[[i]] <- grid.rect(gp=gpar(col="white"))
    }
      
    i=i+1

  }
  
  return(print(grid.arrange(grobs=plotList, ncol=1, top=textGrob(text,gp=gpar(fontsize=20)))))
  
}

```

```{r, eval=FALSE}

#Load information of merged data to be examined

obj.info <- list(c("merge-t0","./data/cellranger-data-full/data.filter.log.merge-t0.rds"),
                 c("merge-t1","./data/cellranger-data-full/data.filter.log.merge-t1.rds"),
                 c("merge-t2","./data/cellranger-data-full/data.filter.log.merge-t2.rds"),
                 c("merge-tot","./data/cellranger-data-full/data.filter.log.merge-tot.rds"))

batch <- c("Stage","Species","Collection","Pair","Individual","Replicate","MSCmedia","Sample","Sex","Age","Number6W","SequencingBatch",
           "Phase","nCount_RNA","nFeature_RNA","percent.mt","PrewashViability","PostwashViability","PostmixViability",
           "CD90","CD73","CD105","CD45.CD34.CD11b.CD19.HLA.DR","Alizarin","OilRed","S.Score","G2M.Score")

#Calculate and plot correlation of batch with first 10 PCs and UMAP
pdf(file=paste0("./output/data-qc-postfilter-subsets-merge-batchcor.pdf"), onefile=TRUE, width=7, height=7)
i=1
for (i in 1:length(obj.info)) {
  print(i)
  text <- obj.info[[i]][1]
  data <- readRDS(obj.info[[i]][2])
  batchPlot(data[[1]],text)
  i=i+1
}
dev.off()

#Visualize batch effects in PC and UMAP space
pdf(file="./output/data-qc-postfilter-subsets-merge-batchviz.pdf", onefile=TRUE, width=18, height=81)
i=1
for (i in 1:length(obj.info)) {
  text <- obj.info[[i]][1]
  data <- readRDS(obj.info[[i]][2])
  print(text)
  qcPlots(data[[1]],text,batch)
  i=i+1
}
dev.off()

```

```{r, eval=FALSE}

#Load information of integrated data to be examined

obj.info <- list(c("int-t0","./data/cellranger-data-full/data.filter.log.indv-cell.int-t0.rds"),
                 c("int-t1","./data/cellranger-data-full/data.filter.log.indv-cell.int-t1.rds"),
                 c("int-t2","./data/cellranger-data-full/data.filter.log.indv-cell.int-t2.rds"),
                 c("int-tot","./data/cellranger-data-full/data.filter.log.indv-cell.int-tot.rds"))

batch <- c("Stage","Species","Collection","Pair","Individual","Replicate","MSCmedia","Sample","Sex","Age","Number6W","SequencingBatch",
           "Phase","nCount_RNA","nFeature_RNA","percent.mt","PrewashViability","PostwashViability","PostmixViability",
           "CD90","CD73","CD105","CD45.CD34.CD11b.CD19.HLA.DR","Alizarin","OilRed","S.Score","G2M.Score")

#Calculate and plot correlation of batch with first 10 PCs and UMAP
pdf(file=paste0("./output/data-qc-postfilter-subsets-int-batchcor.pdf"), onefile=TRUE, width=7, height=7)
i=1
for (i in 1:length(obj.info)) {
  print(i)
  text <- obj.info[[i]][1]
  data <- readRDS(obj.info[[i]][2])
  batchPlot(data,text)
  i=i+1
}
dev.off()

#Visualize batch effects in PC and UMAP space
pdf(file="./output/data-qc-postfilter-subsets-int-batchviz.pdf", onefile=TRUE, width=18, height=81)
i=1
for (i in 1:length(obj.info)) {
  text <- obj.info[[i]][1]
  data <- readRDS(obj.info[[i]][2])
  print(text)
  qcPlots(data,text,batch)
  i=i+1
}
dev.off()

```

```{r, eval=FALSE}

#Load information of integrated data (19k genes) to be examined

obj.info <- list(c("int19k-t0","./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t0.rds"),
                 c("int19k-t1","./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t1.rds"),
                 c("int19k-t2","./data/cellranger-data-full/data.filter.log.indv-cell.int19k-t2.rds"),
                 c("int19k-tot","./data/cellranger-data-full/data.filter.log.indv-cell.int19k-tot.rds"))

batch <- c("Stage","Species","Collection","Pair","Individual","Replicate","MSCmedia","Sample","Sex","Age","Number6W","SequencingBatch",
           "Phase","nCount_RNA","nFeature_RNA","percent.mt","PrewashViability","PostwashViability","PostmixViability",
           "CD90","CD73","CD105","CD45.CD34.CD11b.CD19.HLA.DR","Alizarin","OilRed","S.Score","G2M.Score")

#Calculate and plot correlation of batch with first 10 PCs and UMAP
pdf(file=paste0("./output/data-qc-postfilter-subsets-int19k-batchcor.pdf"), onefile=TRUE, width=7, height=7)
i=1
for (i in 1:length(obj.info)) {
  print(i)
  text <- obj.info[[i]][1]
  data <- readRDS(obj.info[[i]][2])
  batchPlot(data,text)
  i=i+1
}
dev.off()

#Visualize batch effects in PC and UMAP space
pdf(file="./output/data-qc-postfilter-subsets-int19k-batchviz.pdf", onefile=TRUE, width=18, height=81)
i=1
for (i in 1:length(obj.info)) {
  text <- obj.info[[i]][1]
  data <- readRDS(obj.info[[i]][2])
  print(text)
  qcPlots(data,text,batch)
  i=i+1
}
dev.off()

```
